<project>
  <structure>
    <folder name="app">
      <file name="config.py" path="app/config.py" />
      <file name="conn.py" path="app/conn.py" />
      <file name="dump.py" path="app/dump.py" />
      <file name="job.py" path="app/job.py" />
      <file name="main.py" path="app/main.py" />
      <file name="task.py" path="app/task.py" />
      <file name="tree.py" path="app/tree.py" />
      <file name="watch.py" path="app/watch.py" />
      <file name="websocket.py" path="app/websocket.py" />
    </folder>
  </structure>
  <files>
    <file name="config.py" path="app/config.py">
      <summary><![CDATA[import json
import os
from datetime import datetime
from task import Task
class Config:
]]></summary>
      <content><![CDATA[import json
import os
from datetime import datetime
from task import Task

class Config:
    def __init__(self, config_file='config/config.json', tasks_file='config/tasks.json'):
        self.config_file = config_file
        self.tasks_file = tasks_file
        self.config_data = self._load_config()
        self.tasks_data = self._load_tasks()

    def _load_config(self):
        """加载配置文件"""
        if not os.path.exists(self.config_file):
            raise FileNotFoundError(f"Configuration file {self.config_file} not found.")
        with open(self.config_file, 'r') as f:
            return json.load(f)

    def _load_tasks(self):
        """加载任务配置"""
        if not os.path.exists(self.tasks_file):
            return {"tasks": []}
        with open(self.tasks_file, 'r') as f:
            return json.load(f)

    def _save_config(self):
        """保存配置文件"""
        with open(self.config_file, 'w') as f:
            json.dump(self.config_data, f, indent=4)

    def _save_tasks(self):
        """保存任务配置"""
        with open(self.tasks_file, 'w') as f:
            json.dump(self.tasks_data, f, indent=4)

    # CRUD for tasks
    def create_task(self, data):
        # 创建一个新的 Task 实例并保存到任务列表
        task = Task(data)
        self.tasks_data['tasks'].append(task.task_data)
        self._save_tasks()

    def get_task(self, task_name):
        """根据 name 获取任务"""
        for task in self.tasks_data['tasks']:
            if task['name'] == task_name:
                return Task(task)  # 返回 Task 实例
        return None

    def update_task(self, data):
        for existing_task in self.tasks_data['tasks']:
            if existing_task['name'] == data['name']:
                existing_task.update(data)  # 用 Task 的 task_data 更新现有任务的数据字典
                self._save_tasks()
                return True
        return False

    def delete_task(self, task_name):
        """删除任务"""
        task = self.get_task(task_name)
        if task:
            self.tasks_data['tasks'] = [t for t in self.tasks_data['tasks'] if t['name'] != task_name]
            self._save_tasks()
            return True
        return False

    def list_tasks(self):
        """列出所有任务"""
        return [Task(task) for task in self.tasks_data['tasks']]

    # 获取全局配置
    def get_mount_path(self):
        """获取挂载路径"""
        return self.config_data.get("mount_path", "")

    def get_strm_prefix(self):
        """获取 strm 前缀"""
        return self.config_data.get("strm_prefix", "")

    def get_default_task_rules_template(self):
        """获取任务默认规则模板"""
        return self.config_data.get("default_task_rules_template", {})

    def get_logging_level(self):
        """获取日志级别"""
        return self.config_data.get("logging", {}).get("level", "info")

    def get_logging_retention_days(self):
        """获取日志保留天数"""
        return self.config_data.get("logging", {}).get("retention_days", 30)
]]></content>
    </file>
    <file name="conn.py" path="app/conn.py">
      <summary><![CDATA[from p115client import P115Client
from pathlib import Path
import config
class Conn:
    def __init__(self):
]]></summary>
      <content><![CDATA[from p115client import P115Client
from pathlib import Path
import config

class Conn:
	# init the conn
    def __init__(self):
        self.config = config.Config().get_config()
        self.client = P115Client(Path("config/cookie.txt"))

    # get Client
    def get_client(self):
        return self.client

]]></content>
    </file>
    <file name="dump.py" path="app/dump.py">
      <summary><![CDATA[import os
import shutil
import config
class Dump:
    def __init__(self, source_tree, target_tree, task):
]]></summary>
      <content><![CDATA[import os
import shutil
import config

class Dump:
    def __init__(self, source_tree, target_tree, task):
        """
        初始化 Dump 实例

        :param source_tree: 源目录树（路径列表）
        :param target_tree: 目标目录树（路径列表）
        :param task: 当前任务配置
        """
        self.config = config.Config().get_config()
        self.source_tree = source_tree
        self.target_tree = target_tree
        self.task = task  # 任务配置，决定是否执行文件操作

    def run(self):
        """
        执行 dump 操作：根据 source 和 target tree 的差异，执行新增、删除操作
        """
        added, deleted = self.parseTree(self.source_tree, self.target_tree)
        self.add_files(added)
        self.delete_files(deleted)

    def parseTree(self, src_tree_list: list, dest_tree_list: list) -> tuple[list, list]:
        """
        解析源目录（src_tree_list）和目标目录（dest_tree_list），
        返回新增文件列表（added），删除文件列表（deleted）

        根据 rules 中的 method，决定如何处理文件。
        """
        added = []  # 新增的文件（需要生成 .strm 文件等）
        deleted = []  # 需要删除的文件

        # 遍历源目录（src_tree_list），找出新增的文件
        for src_item in src_tree_list:
            # 获取当前文件的处理方法（根据 rules 中的配置）
            method = self._get_method(src_item)
            
            if method == 'ignore':
                continue  # 忽略该文件，不做处理
            
            # 如果 method 是 'strm'，则需要生成 .strm 文件
            if method == 'strm':
                strm_file = src_item + '.strm'  # 直接生成 .strm 文件名
                if strm_file not in dest_tree_list:  # 如果目标目录没有该 .strm 文件
                    added.append(src_item)  # 将源文件加入新增列表，用于创建 .strm 文件
            else:
                # 对于其他文件（如 copy, symlink, virtual），直接加入新增列表
                added.append(src_item)

        # 遍历目标目录（dest_tree_list），找出需要删除的文件
        for dest_item in dest_tree_list:
            # 获取当前目标文件的处理方法（根据 rules 中的配置）
            method = self._get_method(dest_item)
            
            if method == 'ignore':
                continue  # 忽略该文件，不做处理
            
            # 如果目标目录中是 .strm 文件，检查对应的源文件是否存在
            if method == 'strm':
                corresponding_source_file = dest_item.replace('.strm', '')  # 去掉 .strm 后缀，得到源文件路径
                if corresponding_source_file not in src_tree_list:  # 如果源目录没有对应的文件
                    deleted.append(dest_item)  # 删除目标目录中的 .strm 文件
            else:
                # 删除其他类型的文件（copy, symlink, virtual）
                deleted.append(dest_item)

        return added, deleted

    def _process_file(self, file_path):
        """根据任务配置执行文件的处理操作"""
        if self._is_ignored(file_path):
            return
        elif self._is_copyable(file_path):
            self._copy_file(file_path)
        elif self._is_symlink(file_path):
            self._create_symlink(file_path)
        elif self._is_strm(file_path):
            self._create_strm(file_path)
        elif self._is_virtual(file_path):
            self._create_virtual_file(file_path)

    def _is_ignored(self, file_path):
        """ 判断是否需要忽略文件 """
        return self._get_method(file_path) == 'ignore'

    def _is_copyable(self, file_path):
        """ 判断文件是否需要复制 """
        return self._get_method(file_path) == 'copy'

    def _is_symlink(self, file_path):
        """ 判断文件是否需要创建软链接 """
        return self._get_method(file_path) == 'symlink'

    def _is_strm(self, file_path):
        """ 判断文件是否需要创建 .strm 文件 """
        return self._get_method(file_path) == 'strm'

    def _is_virtual(self, file_path):
        """ 判断文件是否需要创建 0KB 虚拟文件 """
        return self._get_method(file_path) == 'virtual'

    def _get_method(self, file_path):
        """ 根据文件的扩展名从任务配置中获取对应的处理方法 """
        file_extension = os.path.splitext(file_path)[1]
        for rule in self.task['rules']:
            if file_extension in rule['extensions']:
                return rule['method']
        return 'ignore'  # 默认忽略

    def _copy_file(self, file_path):
        """ 复制文件 """
        target_path = os.path.join(self.config["mount_path"], file_path)
        target_dir = os.path.dirname(target_path)

        # 确保目标目录存在
        if not os.path.exists(target_dir):
            os.makedirs(target_dir)

        shutil.copy(file_path, target_path)
        print(f"Copied file: {file_path} to {target_path}")

    def _create_symlink(self, file_path):
        """ 创建软链接 """
        target_path = os.path.join(self.config["mount_path"], file_path)
        target_dir = os.path.dirname(target_path)

        # 确保目标目录存在
        if not os.path.exists(target_dir):
            os.makedirs(target_dir)

        os.symlink(file_path, target_path)
        print(f"Created symlink for: {file_path} to {target_path}")

    def _create_strm(self, file_path):
        """ 创建 .strm 文件 """
        strm_path = os.path.join(self.config["mount_path"], file_path + '.strm')
        strm_prefix = self.config.get("strm_prefix", "")
        strm_url = strm_prefix + file_path
        with open(strm_path, 'w') as f:
            f.write(strm_url)
        print(f"Created .strm file for: {file_path}")

    def _create_virtual_file(self, file_path):
        """ 创建 0KB 虚拟文件 """
        target_path = os.path.join(self.config["mount_path"], file_path)
        target_dir = os.path.dirname(target_path)

        # 确保目标目录存在
        if not os.path.exists(target_dir):
            os.makedirs(target_dir)

        with open(target_path, 'wb') as f:
            pass  # 创建一个空的 0KB 文件
        print(f"Created virtual file for: {file_path}")

    def _delete_file(self, file_path):
        """ 删除目标文件 """
        target_path = os.path.join(self.config["mount_path"], file_path)

        # 确保目标目录存在，避免删除操作失败
        target_dir = os.path.dirname(target_path)
        if not os.path.exists(target_dir):
            print(f"Directory {target_dir} does not exist. Skipping deletion for: {file_path}")
            return

        if os.path.exists(target_path):
            os.remove(target_path)
            print(f"Deleted file: {target_path}")
        else:
            print(f"File not found for deletion: {target_path}")
]]></content>
    </file>
    <file name="job.py" path="app/job.py">
      <summary><![CDATA[import conn
import tree
import dump
import task
from datetime import datetime
]]></summary>
      <content><![CDATA[import conn
import tree
import dump
import task
from datetime import datetime
from task import Task

class Job:
    def __init__(self, name, task):
        """
        初始化 Job 实例
        
        :param name: 任务名称
        :param task: 任务实例（Task 类实例），包含任务配置和规则
        """
        self.name = name
        self.task = task  # 传入的 Task 类实例，包含任务的配置和规则
        self.status = 'pending'  # 任务的初始状态
        self.logs = []  # 日志记录
        self.conn = conn.Conn()  # 初始化连接实例
        self.tree = tree.Tree()  # 初始化目录树实例
        self.dump = dump.Dump()  # 初始化 dump 实例
        self.start_time = None  # 任务开始时间
        self.end_time = None  # 任务结束时间

    def start(self):
        """
        启动任务
        1. 获取客户端
        2. 获取源目录树和目标目录树
        3. 执行增量同步或全量同步
        """
        self.start_time = datetime.now()  # 记录任务开始时间
        self.status = 'running'  # 设置任务状态为运行中
        self.logs.append(f"Job {self.name} started at {self.start_time}.")
        
        try:
            # 获取 client
            client = self.conn.get_client()
            
            # 获取源目录树和目标目录树
            source_tree = self.tree.get_source_tree(client, self.task.get_source_path())
            target_tree = self.tree.get_target_tree(self.task.get_target_path())
            
            # 执行增量同步（dump）
            self.dump.run(source_tree, target_tree, self.task)
            
            # 标记任务完成
            self.complete()
        
        except Exception as e:
            self.fail(f"Job failed with error: {str(e)}")

    def complete(self):
        """标记任务为完成，并记录日志"""
        self.end_time = datetime.now()  # 记录任务结束时间
        self.status = 'completed'  # 设置任务状态为已完成
        self.logs.append(f"Job {self.name} completed at {self.end_time}. Duration: {self.end_time - self.start_time}")

    def fail(self, reason):
        """任务失败时的处理"""
        self.status = 'failed'  # 设置任务状态为失败
        self.logs.append(f"Job {self.name} failed: {reason}")

    def update_logs(self, message):
        """更新日志"""
        self.logs.append(message)

    def get_logs(self):
        """获取日志"""
        return '\n'.join(self.logs)

    def schedule(self):
        """定时调度任务（例如使用 Cron 表达式）"""
        # 你可以在此方法中使用像 `schedule` 或 `APScheduler` 之类的库来设置定时任务
        pass


# 示例用法
if __name__ == "__main__":
    # 假设 Task 类实例已经被创建，task 是一个实例化后的 Task 对象
    task = Task()  # 假设 Task 类已经实现并被正确初始化
    
    # 创建并启动任务
    job = Job(name="Sync Job 1", task=task)
    job.start()
    
    # 输出任务日志
    print(job.get_logs())
]]></content>
    </file>
    <file name="main.py" path="app/main.py">
      <summary><![CDATA[from flask import Flask, render_template
from flask_socketio import SocketIO, emit
app = Flask(__name__)
socketio = SocketIO(app)
@app.route('/')
]]></summary>
      <content><![CDATA[from flask import Flask, render_template
from flask_socketio import SocketIO, emit

app = Flask(__name__)
socketio = SocketIO(app)

# 路由和其他逻辑
@app.route('/')
def index():
    return render_template('index.html')

@app.route('/api/job', methods=['GET'])
def get_tasks():
    # 返回任务列表的 API 示例
    return {"Jobs": []}

# 监听 WebSocket 事件
@socketio.on('connect')
def handle_connect():
    print("Client connected")
    emit('status_update', {'message': 'Connected to WebSocket server'})

@socketio.on('disconnect')
def handle_disconnect():
    print("Client disconnected")

# WebSocket 任务状态更新
def send_job_status_update(job_name, status):
    emit('status_update', {'task_name': job_name, 'status': status}, broadcast=True)

if __name__ == '__main__':
    socketio.run(app, debug=True)
]]></content>
    </file>
    <file name="task.py" path="app/task.py">
      <summary><![CDATA[class Task:
    def __init__(self, data):
        """
        初始化 Task 实例
        :param data: 包含任务数据的字典
]]></summary>
      <content><![CDATA[class Task:
    def __init__(self, data):
        """
        初始化 Task 实例
        
        :param data: 包含任务数据的字典
        """
        self.data = data  # 存储任务数据

    def get_name(self):
        """获取任务名称"""
        return self.data.get('name')

    def get_status(self):
        """获取任务状态"""
        return self.data.get('status', 'pending')

    def get_source_path(self):
        """获取源路径"""
        return self.data.get('source_path')

    def get_target_path(self):
        """获取目标路径"""
        return self.data.get('target_path')

    def get_rules(self):
        """获取任务规则"""
        return self.data.get('rules', [])

    def get_logs(self):
        """获取任务日志"""
        return self.data.get('logs', [])

    def get_created_at(self):
        """获取任务创建时间"""
        return self.data.get('created_at')

    def get_last_run_time(self):
        """获取任务最后运行时间"""
        return self.data.get('last_run_time')

    def get_next_run_time(self):
        """获取任务下次运行时间"""
        return self.data.get('next_run_time')

    # New update method
    def update(self, data):
        """更新任务数据"""
        self.data.update(data)  # 用传入的数据字典更新任务数据
]]></content>
    </file>
    <file name="tree.py" path="app/tree.py">
      <summary><![CDATA[import os
from p115client import tool
class Tree:
    def get_source_tree(self, client, path):
        try:
]]></summary>
      <content><![CDATA[import os
from p115client import tool

class Tree:

    def get_source_tree(self, client, path):
        ### 解析115目录树，生成目录数组
        try:
            it = tool.export_dir_parse_iter(
                client=client, 
                export_file_ids=path, 
                target_pid=path, 
                parse_iter=tool.parse_export_dir_as_dict_iter, 
                delete=True,
                async_=False,
                show_clock=True)
            i = 0
            path_index = {}
            source_tree = []
            for item in it:
                i += 1
                parent = path_index.get(item['parent_key'])
                if parent is None:
                    item['path'] = ''
                else:
                    if i == 2 and path.endswith(item['name']):
                        item['path'] = path
                    else:
                        item['path'] = "{0}/{1}".format(parent['path'], item['name'])
                path_index[item['key']] = item
                if item['path'] != '':
                    source_tree.append(item['path'].replace('/', os.sep))
            return source_tree
        except Exception as e:
            ### self.logger.error('生成目录树出错: %s' % e)
            raise e
        
    def get_target_tree(self, base_dir: str, root_dir: str, target_tree: list):
        ### 获取目标路径目录树，用于处理差异
        if not os.path.exists(root_dir):
            return target_tree
        dirs = os.listdir(root_dir)
        for dir in dirs:
            item = os.path.join(root_dir, dir)
            target_tree.append(item.lstrip(base_dir + os.sep))
            if os.path.isfile(item):
                # 如果是文件，则不用递归
                continue
            self.get_target_tree(base_dir, item, target_tree)
        return target_tree]]></content>
    </file>
    <file name="watch.py" path="app/watch.py">
      <summary><![CDATA[from flask import request
def handle_webhook(event_data):
    print(f"Received webhook event: {event_data}")
]]></summary>
      <content><![CDATA[# Webhook 处理模块，监听来自 CloudDrive2 的 Webhook 消息

from flask import request

def handle_webhook(event_data):
    # 处理 Webhook 事件，更新任务
    print(f"Received webhook event: {event_data}")
    # 更新任务状态或触发任务处理
]]></content>
    </file>
    <file name="websocket.py" path="app/websocket.py">
      <summary><![CDATA[from flask_socketio import emit
def send_job_status_update(job_name, status):
    emit('status_update', {'task_name': job_name, 'status': status}, broadcast=True)
]]></summary>
      <content><![CDATA[from flask_socketio import emit

def send_job_status_update(job_name, status):
    emit('status_update', {'task_name': job_name, 'status': status}, broadcast=True)
]]></content>
    </file>
  </files>
</project>
